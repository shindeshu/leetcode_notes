## Problem

Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.

A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).

Example 1:

![](images/931.jpg)

## Solution

basically, for each idx in the top row we compute the min cost to get to the bottom. the minimum of these n is the minimum cost overall.

also imp: keep a cache to avoid recomputing, otherwise test cases fail.

## Code

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        N = len(matrix) # num cols
        cache = {}
        def dfs(r, c):
            if r == N:
                # success
                return 0
            if c<0 or c==N:
                # failure / outof bounds
                return float("inf")
            if (r, c) in cache:
                return cache[(r, c)]
            # cost at curr pos, is the curr pos + minimum in the below adjacent position
            ans = matrix[r][c] + \
                    min(dfs(r+1, c), dfs(r+1, c+1), dfs(r+1, c-1))
            cache[(r,c)]=ans
            return ans
        res = float("inf")
        for c in range(N):
            # compute the min sum from 0,c to the bottom row
            res = min(res, dfs(0, c))
        return res
```